import csv
import graph_tool.all as gt
from collections import defaultdict
import numpy as np



class sbm():

    def __init__(self):
        self.g = None ## network

        self.admissions = [] ## list of admissions of patients
        self.icd9 = [] ## list of disease icd9 codes

        self.state = None ## inference state from graphtool
        self.groups = {} ## results of group membership from inference
        self.mdl = np.nan ## minimum description length of inferred state
        self.L = np.nan ## number of levels in hierarchy

    def make_graph(self,admin_num = 0, age=False, ethnicity=False):
        '''
        optional argument:
        - admin_num: only consider the given number of admissions
        '''


        ## make a graph
        ## create a graph
        g = gt.Graph(directed=False)
        ## define node properties
        ## name: docs - title, words - 'word'
        ## kind: docs - 0, words - 1
        name = g.vp["name"] = g.new_vp("string")
        kind = g.vp["kind"] = g.new_vp("int")

        if(age or ethnicity):
            weight = g.ep["weight"] = g.new_ep("int")
        if(age):
            m = g.add_vertex()
            f = g.add_vertex()
            name[m] = "M"
            kind[m] = 2
            name[f] = "F"
            kind[f] = 2
        if(ethnicity):
            # ethnicities = ['hispanic', 'white', 'black', 'asian', 'native', 'unknown', 'other']
            h = g.add_vertex()
            name[h] = "hispanic"
            kind[h] = 3
            w = g.add_vertex()
            name[w] = "white"
            kind[w] = 3
            b = g.add_vertex()
            name[b] = "black"
            kind[b] = 3
            a = g.add_vertex()
            name[a] = "asian"
            kind[a] = 3
            n = g.add_vertex()
            name[n] = "native"
            kind[n] = 3
            u = g.add_vertex()
            name[u] = "unknown"
            kind[u] = 3
            o = g.add_vertex()
            name[o] = "other"
            kind[o] = 3


    


        admin_add = defaultdict(lambda: g.add_vertex())
        icd9_add = defaultdict(lambda: g.add_vertex())

        with open('admission_patients_demograhics_morbidities.csv') as csv_file:
            csv_reader = csv.DictReader(csv_file, delimiter=',')
            count = 0
            for row in csv_reader:

                p = admin_add[row['hadm_id']]
                name[p] = row['hadm_id']
                kind[p] = 0

                icdList = row['icd9_4_digits'].split(',')
                for icd9 in icdList:
                    d=icd9_add[icd9]
                    name[d] = icd9
                    kind[d] = 1
                    e = g.add_edge(p,d)
                    if(age or ethnicity):
                        g.ep.weight[e]=0

                if(age):
                    
                    if(row['gender']=="M"):
                        e = g.add_edge(p,m)
                        g.ep.weight[e]=-1
                    else:
                        e = g.add_edge(p,f)
                        g.ep.weight[e]=-1

                if(ethnicity):

                    if(row['ethnicity_grouped']=="hispanic"):
                        e = g.add_edge(p,h)
                        g.ep.weight[e]=1
                    if(row['ethnicity_grouped']=="white"):
                        e = g.add_edge(p,w)
                        g.ep.weight[e]=1
                    if(row['ethnicity_grouped']=="black"):
                        e = g.add_edge(p,b)
                        g.ep.weight[e]=1
                    if(row['ethnicity_grouped']=="asian"):
                        e = g.add_edge(p,a)
                        g.ep.weight[e]=1
                    if(row['ethnicity_grouped']=="native"):
                        e = g.add_edge(p,n)
                        g.ep.weight[e]=1
                    if(row['ethnicity_grouped']=="unknown"):
                        e = g.add_edge(p,u)
                        g.ep.weight[e]=1
                    if(row['ethnicity_grouped']=="other"):
                        e = g.add_edge(p,o)
                        g.ep.weight[e]=1
                    
                        


                count+=1
                if(count==admin_num):
                    break

        # g.save(graph_title+'.gt.gz')

        self.g = g
        self.icd9 = [g.vp['name'][v] for v in g.vertices() if g.vp['kind'][v] == 1]
        self.admissions = [g.vp['name'][v] for v in g.vertices() if g.vp['kind'][v] == 0]

        return self

    def save_graph(self,filename = 'graph.gt.gz'):
        '''
        Save the word-document network generated by make_graph() as filename.
        Allows for loading the graph without calling make_graph().
        '''
        self.g.save(filename)

    def load_graph(self,filename = 'graph.gt.gz'):
        '''
        Load a word-document network generated by make_graph() and saved with save_graph().
        '''
        self.g = gt.load_graph(filename)
        self.icd9 = [ self.g.vp['name'][v] for v in  self.g.vertices() if self.g.vp['kind'][v]==1   ]
        self.admissions = [ self.g.vp['name'][v] for v in  self.g.vertices() if self.g.vp['kind'][v]==0   ]
    

    def fit(self,multilayer=False):
            '''
            Fit the sbm to the patient-icd9-demographic network.
            '''
            g = self.g
            if g is None:
                print('No data to fit the SBM. Load some data first (make_graph)')
            else:

                #cluster different kind of nodes together
                clabel = g.vp['kind']

                state_args = {'clabel': clabel, 'pclabel': clabel}
                

                if(multilayer):
                    state_args["ec"] = g.ep.weight
                    state_args["layers"] = True
                    state = gt.minimize_nested_blockmodel_dl(g,state_args=dict(base_type=gt.gt.LayeredBlockState,**state_args))

                else:
                # base_type = gt.BlockState
                    state = gt.minimize_nested_blockmodel_dl(g,state_args=dict(base_type=gt.BlockState,**state_args))

                gt.mcmc_equilibrate(state, wait=100, mcmc_args=dict(niter=10))


                print(state)
                self.state = state
                ## minimum description length
                self.mdl = state.entropy()
    # def stuff(self):
    #     gt.graph_draw(self.g,output="g.pdf")

    #     print(gt.is_bipartite(g))
    #     # for v in g.iter_vertices():
    #     #     print(v)
    #     #     print(g.vp.name[v])
    #     #     print(g.vp.kind[v])

    #     for e in self.g.iter_edges():
    #         print(e)
    #         print(self.g.vp.name[e[0]],g.vp.name[e[1]])
    #         # print(e,e.source(), e.target())
    #         # print(g.vp.name[e.source()],g.vp.name[e.target()])

    #     state = gt.minimize_nested_blockmodel_dl(g)
    #     gt.mcmc_equilibrate(state, wait=100, mcmc_args=dict(niter=10))

    #     state.print_summary()
    #     print(state.entropy())
    #     gt.draw_hierarchy(state, subsample_edges=1000, layout = "bipartite",output="min.pdf")
